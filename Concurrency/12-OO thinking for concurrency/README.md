# 如何用面向对象思想写好并发程序?
在 Java 语言里，面 向对象思想能够让并发编程变得更简单。

那如何才能用面向对象思想写好并发程序呢?结合我自己的工作经验来看，我觉得你可以从封装
共享变量、识别共享变量间的约束条件和制定并发访问策略这三个方面下手。

## 1. 封装共享变量
**封装**：将属性和实现细节封装在对象内部，外界对象只能通过目标对象提供的公共方法来间接访问这些内部属性。

利用面向对象思想写并发程序的思路，其实就这么简单:**将共享变量作为对象属性封装在内部， 对所有公共方法制定并发访问策略。**就拿很多统计程序都要用到计数器来说，下面的计数器程序 共享变量只有一个，就是 value，我们把它作为 Counter 类的属性，并且将两个公共方法 get() 和 addOne() 声明为同步方法，这样 Counter 类就成为一个线程安全的类了。

```
public class Counter {
  private long value;
  synchronized long get(){
    return value;
  }
  synchronized long addOne(){
    return ++value;
  }
}
```
当然，实际工作中，很多的场景都不会像计数器这么简单，经常要面临的情况往往是有很多的共享变量，例如，信用卡账户有卡号、姓名、身份证、信用额度、已出账单、未出账单等很多共享 变量。这么多的共享变量，如果每一个都考虑它的并发安全问题，那我们就累死了。但其实仔细观察，你会发现，很多共享变量的值是不会变的，例如信用卡账户的卡号、姓名、身份证。对于**这些不会发生变化的共享变量，建议你用 final 关键字来修饰**。这样既能避免并发问题，也能很明了地表明你的设计意图，让后面接手你程序的兄弟知道，你已经考虑过这些共享变量的并发安全问题了。

## 2.识别共享变量间的约束条件
识别共享变量间的约束条件非常重要。因为**这些约束条件，决定了并发访问策略。**

例如，库存管理里面有个合理库存的概念，库存量不能太高，也不能太低，它有一个上限和一个下限。关于这 些约束条件，我们可以用下面的程序来模拟一下。在类 SafeWM 中，声明了两个成员变量 upper 和 lower，分别代表库存上限和库存下限，这两个变量用了 AtomicLong 这个原子类，原 子类是线程安全的，所以这两个成员变量的 set 方法就不需要同步了。

```
public class SafeWM(){
  //库存上限
  private final AtomicLong upper = new AtomicLong(0);
  //库存下限
  private final AtomicLong lower = new AtomicLong(0);

  //设置库存上限
  void setUpper(long v){
    upper.set(v);
  }

  //设置库存下限
  void setLower(long v){
    lower.set(v);
  }
}

```

虽说上面的代码是没有问题的，但是忽视了一个约束条件，就是**库存下限要小于库存上限**，这个 约束条件能够直接加到上面的 set 方法上吗?我们先直接加一下看看效果(如下面代码所示)。 我们在 setUpper() 和 setLower() 中增加了参数校验，这乍看上去好像是对的，但其实存在并发 问题，问题在于存在竞态条件。这里我顺便插一句，其实当你看到代码里出现 if 语句的时候，就 应该立刻意识到可能存在竞态条件。

我们假设库存的下限和上限分别是 (2,10)，线程 A 调用 setUpper(5) 将上限设置为 5，线程 B 调用 setLower(7) 将下限设置为 7，如果线程 A 和线程 B 完全同时执行，你会发现线程 A 能够 通过参数校验，因为这个时候，下限还没有被线程 B 设置，还是 2，而 5>2;线程 B 也能够通 过参数校验，因为这个时候，上限还没有被线程 A 设置，还是 10，而 7<10。当线程 A 和线程 B 都通过参数校验后，就把库存的下限和上限设置成 (7, 5) 了，显然此时的结果是**不符合库存下限要小于库存上限这个约束条件的。**

```
public class SafeWM {
  // 库存上限
  private final AtomicLong upper = new AtomicLong(0); // 库存下限
  private final AtomicLong lower = new AtomicLong(0);
  // 设置库存上限
  void setUpper(long v){
    // 检查参数合法性
    if (v < lower.get()) {
      throw new IllegalArgumentException();
    }
    upper.set(v);
  }
  // 设置库存下限
  void setLower(long v){
    // 检查参数合法性
    if (v > upper.get()) {
      throw new IllegalArgumentException();
    }
    lower.set(v);
  }
// 省略其他业务代码
}
```

在没有识别出库存下限要小于库存上限这个约束条件之前，我们制定的并发访问策略是利用原子 类，但是这个策略，完全不能保证库存下限要小于库存上限这个约束条件。所以说，在设计阶 段，我们一定要识别出所有共享变量之间的约束条件，如果约束条件识别不足，很可能导致制定 的并发访问策略南辕北辙。
共享变量之间的约束条件，反映在代码里，**基本上都会有 if 语句，所以，一定要特别注意竞态条件。**

## 3. 制定并发访问策略
1. **避免共享**:避免共享的技术主要是利于线程本地存储以及为每个任务分配独立的线程。
2. **不变模式**:这个在 Java 领域应用的很少，但在其他领域却有着广泛的应用，例如 Actor 模
式、CSP 模式以及函数式编程的基础都是不变模式。
3. **管程及其他同步工具**:Java 领域万能的解决方案是管程，但是对于很多特定场景，使用 Java
 并发包提供的读写锁、并发容器等同步工具会更好。

 除了这些方案之外，还有一些宏观的原则需要你了解。这些宏观原则，有助于你写出“健壮”的
并发程序。这些原则主要有以下三条。

1. **优先使用成熟的工具类**:Java SDK 并发包里提供了丰富的工具类，基本上能满足你日常的需 要，建议你熟悉它们，用好它们，而不是自己再“发明轮子”，毕竟并发工具类不是随随便便 就能发明成功的。
2. **迫不得已时才使用低级的同步原语**:低级的同步原语主要指的是 synchronized、Lock、 Semaphore 等，这些虽然感觉简单，但实际上并没那么简单，一定要小心使用。
3. **避免过早优化**:安全第一，并发程序首先要保证安全，出现性能瓶颈后再优化。在设计期和开 发期，很多人经常会情不自禁地预估性能的瓶颈，并对此实施优化，但残酷的现实却是:性能瓶颈不是你想预估就能预估的。
